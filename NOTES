Possible Problems
~~~~~~~~~~~~~~~~~

 - See GHC trac ticket #1852. Floats are padded to word size (4 extra bytes
 on a 64 bit machine) by putting an appropriate CmmLit before them. On fasm
 this is nessecary and forces the NCG to produce correct code. On viaC, this
 isn't nessecary so it strips this padding out. What approach does llvm need?

 - When converting Rational's to floats and doubles, we use special tags for
 unrepresentable numbers, such as NAN, INFINITY... ect. Not sure if this is
 actual valid in LLVM.

 - Check that the approach taken for CmmBlock and CmmLabelDiff off in CmmData
 sections is correct.
 
 - Should I be converting CmmString's like I am into ASCII form when I can and
 hex otherwise? If the string is pure 16bit unicode will this be fine? Maybe
 I should be making them an array of 8 bit numbers?

 - Check the Integer to Int conversion is OK. Am I printing signed/unsigned
 correctly?
 
 - Do I need to handle the GcPtr CmmType differently from just a bit type?
 
 - Should I be using FiniteMap instead of Data.Map?

 - SPARC/CodeGen/Gen32.hs seems to have a few special cases for CmmMachOp.
 Perhaps these should also be handled in LLVM to improve performance?

 - tail call only supported on x86/x86-64 and PowerPC. SPARC?


Todo
~~~~

 - Fix warnings.

 - Improve Type saftey of LLVM module (e.g split out pointers to own data type,
 to limit where they can be used).

 - Use OrdList instead of [].

 - Use a new Monad instead of passing LlvmEnv around everywhere.

 - Llvm module fixed 32bit. Change to work with all word widths.

 - Change names of getFloatWidth and getBitWidth. Not very informative.

 - unify some of the code in MachOp handling.

 - 'commafy' SDoc function to produce comman sep SDoc from list.

 - nice function for creating and assigning expression to new local var.

 - Make list of tmp vars.

 - Shifts don't need type information for literal values of the shift. Other
 instructions might not either. Check pprLlvm.

 - panic should be a new function which handles first text printing.

 - return pointer width in Llvm module

 - Look at using LLVM intrinsic functions. There are a few math functions.
 Also, there is a smul_overflow detect function.

