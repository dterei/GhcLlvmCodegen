Possible Problems
~~~~~~~~~~~~~~~~~

 - Do I need to specify the data layout?

 - See GHC trac ticket #1852. Floats are padded to word size (4 extra bytes
 on a 64 bit machine) by putting an appropriate CmmLit before them. On fasm
 this is nessecary and forces the NCG to produce correct code. On viaC, this
 isn't nessecary so it strips this padding out. What approach does llvm need?

 - Should I be using FiniteMap instead of Data.Map?

 - Can't seem to find any evidence of pointer tagging. Is it still used?

 - Do I need to handle the GcPtr CmmType differently from just a bit type?

 - SPARC/CodeGen/Gen32.hs seems to have a few special cases for CmmMachOp.
 Perhaps these should also be handled in LLVM to improve performance?

 - tail call only supported on x86/x86-64 and PowerPC. SPARC?


Todo
~~~~

 - Get working with registered build.

 - look into lto/gold.

 - Use a new Monad instead of passing LlvmEnv around everywhere.

 - Use OrdList instead of [].

 - Should be able to put all CmmProc and CmmData labels in environment at start
 and after that, can print out LLVM IR as I generate it for each data and proc
 instead of storing.

 - Look at using LLVM intrinsic functions. There are a few math functions.
 Also, there is a smul_overflow detect function.

 - Improve Type saftey of LLVM module (e.g split out pointers to own data type,
 to limit where they can be used). More type checking in ppr stage.

 - Rearrange some functions and files better.

 - Look at merging some of code with NCG.


BUGS
~~~~

 - ghc-stage2 built with llvm segaults.

 - llvm opt pass simplifycfg causes program to segfault when run.

 - float NAN handling. check testsuite arith016. NAN should be equal to all
 numbers, e.g NAN == 0.0 => True. However, I return false at moment. Llvm has
 two types of float ops for if NAN == 0.0 should be true or false, check right
 one is being used. Need to use unordered (e.g ueq) instead of ordered cmps.

