LLVM Back-end for GHC.

Author: David Terei

General Points
~~~~~~~~~~~~~~

 - Don't use the 'NoReturn' function attribute. It causes the llvm optimiser to
 produce bad code as it replaces the following sequence of intructions:

  tail call fastcc void (i32,i32,i32,i32)* %nnO( i32 %nnP,i32 %nnQ,i32 %nnR,i32 %nnS )
  ret void

 with:

  tail call fastcc void (i32,i32,i32,i32)* %nnO( i32 %nnP,i32 %nnQ,i32 %nnR,i32 %nnS )
  unreachable
 
 which stops llc producing native code that actually tail calls and thus leads
 to a runtime segfault / stack smash.


Possible Problems
~~~~~~~~~~~~~~~~~

 - See GHC trac ticket #1852. Floats are padded to word size (4 extra bytes
 on a 64 bit machine) by putting an appropriate CmmLit before them. On fasm
 this is nessecary and forces the NCG to produce correct code. On viaC, this
 isn't nessecary so it strips this padding out. What approach does llvm need?

 - Should I be using FiniteMap instead of Data.Map?

 - SPARC/CodeGen/Gen32.hs seems to have a few special cases for CmmMachOp.
 Perhaps these should also be handled in LLVM to improve performance?

 - tail call only supported on x86/x86-64 and PowerPC. SPARC?

 - LLVM requires all control flow to be explicit, incluiding 'ret void'.
 Cmm doesn't, ret void is assumed like in C. For most code this is fine as with
 CPS all the blocks are ended with tail calls or branhces. However with the
 handwritten Cmm it can occur although currently all cases are handled
 correctly.


Todo
~~~~

 - look into lto/gold.

 - Use a new Monad instead of passing LlvmEnv around everywhere.

 - Use OrdList instead of [].

 - Should be able to put all CmmProc and CmmData labels in environment at start
 and after that, can print out LLVM IR as I generate it for each data and proc
 instead of storing.

 - Look at using LLVM intrinsic functions. There are a few math functions.
 Also, there is a smul_overflow detect function.

 - Improve Type saftey of LLVM module (e.g split out pointers to own data type,
 to limit where they can be used). More type checking in ppr stage.

 - Rearrange some functions and files better.

 - Look at merging some of code with NCG.

 - handling of llvmvar or llvmtype for func sig isnt nice. Whole func sig handling
 could be better really.

 - handling of global regs and custom calling convention ugly. Lots of very
 similar code, need to change to handle multiple architectures easily.

 - LlvmCodeGen.CodeGen.genCall code for foreign calls is quite complex, could
 use a cleanup.


BUGS
~~~~

 - foreign calls on Mac OS X don't work. Seems to be because LLVM isn't
 generating correct code. All system calls must be 16 byte aligned in OS X
 and llvm isn't respecting this. Not sure if its a bug in LLVM or due to my
 changes to llvm.

