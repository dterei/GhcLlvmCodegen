LLVM Back-end for GHC.

Author: David Terei

General Points
~~~~~~~~~~~~~~

 - Don't use the 'NoReturn' function attribute. It causes the llvm optimiser to
 produce bad code as it replaces the following sequence of intructions:

  tail call fastcc void (i32,i32,i32,i32)* %nnO( i32 %nnP,i32 %nnQ,i32 %nnR,i32 %nnS )
  ret void

 with:

  tail call fastcc void (i32,i32,i32,i32)* %nnO( i32 %nnP,i32 %nnQ,i32 %nnR,i32 %nnS )
  unreachable
 
 which stops llc producing native code that actually tail calls and thus leads
 to a runtime segfault / stack smash.


Possible Problems
~~~~~~~~~~~~~~~~~

 - See GHC trac ticket #1852. Floats are padded to word size (4 extra bytes
 on a 64 bit machine) by putting an appropriate CmmLit before them. On fasm
 this is nessecary and forces the NCG to produce correct code. On viaC, this
 isn't nessecary so it strips this padding out. What approach does llvm need?

 - Should I be using FiniteMap instead of Data.Map?

 - SPARC/CodeGen/Gen32.hs seems to have a few special cases for CmmMachOp.
 Perhaps these should also be handled in LLVM to improve performance?

 - tail call only supported on x86/x86-64 and PowerPC. SPARC?

 - Using hardcoded names for my implementation of STG virtual registers. I
 think this is fine but should check what are the rules for the unique name
 generator to make sure it can't confict. Or perhaps generate unique names for
 them at the start of each function.


Todo
~~~~

 - look into lto/gold.

 - Use a new Monad instead of passing LlvmEnv around everywhere.

 - Use OrdList instead of [].

 - Should be able to put all CmmProc and CmmData labels in environment at start
 and after that, can print out LLVM IR as I generate it for each data and proc
 instead of storing.

 - Look at using LLVM intrinsic functions. There are a few math functions.
 Also, there is a smul_overflow detect function.

 - Improve Type saftey of LLVM module (e.g split out pointers to own data type,
 to limit where they can be used). More type checking in ppr stage.

 - Rearrange some functions and files better.

 - Look at merging some of code with NCG.

 - handling of llvmvar or llvmtype for func sig isnt nice. Whole func sig
 handling could be better really.

 - handling of global regs and custom calling convention ugly. Lots of very
 similar code, need to change to handle multiple architectures easily.
 DONE: improved a fair amount. Could still see if can be cleaned up more. Could
 extend the RealReg type for example to include name and llvm type, making the
 getRealRegReg and getRealRegArg functions very simple (and removing the
 lmBase... functions).

 - LlvmCodeGen.CodeGen.genCall code for foreign calls is quite complex, could
 use a cleanup.


Bugs
~~~~

 - Now that we have own calling convention in LLVM, need to choose which calling
 convention to use depending on if the back-end is being built in registered or
 unregistered mode.

 - foreign calls on Mac OS X don't work. Seems to be because LLVM isn't
 generating correct code. All system calls must be 16 byte aligned in OS X
 and llvm isn't respecting this. Not sure if its a bug in LLVM or due to my
 changes to llvm.

 - LLVM requires all control flow to be explicit, incluiding 'ret void'.
 Cmm doesn't, ret void is assumed like in C. For most code this is fine as with
 CPS all the blocks are ended with tail calls or branhces. However with the
 handwritten Cmm it can occur although currently all cases are handled
 correctly. NOTE: This does manifest! Happens on x86-64 for handwritten
 cmm code! Causes failure when trying to bootstrap GHC.

 - If a function is initially used as a label (e.g the address of it is taken)
 then the code generator creates an external reference label for it. Later
 if that function is called directly as a funciton then as it has previously
 been defined as a function the code generator gets confused and creates
 an invalid bitcast. Could either look to redefine the function label when
 more information is encountered, or just fix up the bitcast.

 - HRay on X86-64 segfaults on some scenes (e.g trans2)

Merge Questions
~~~~~~~~~~~~~~~

 - How to use code from NCG? e.g Should I add nativeGen to the llvm back-end
 cabal.in hs-source-dirs list? How is the case of unregistered handled since
 LLVM works in both modes but NCG isn't usually built in unregistered mode.

Merge Problems
~~~~~~~~~~~~~~

== David Peixotto ==

 - Nice if -ddump-llvm implies -fllvm
 - Does it work with the -dynamic flag?

== Simon Marlow ==

Here's a patch review.  I think one round of feedback should be enough: most of my suggestions are cleanups or optimisations, there are very few XXX's.  On the whole the patch looks fine.  I haven't done a deep review of the code - there's quite a lot of it, and I'm not an LLVM expert, so this is a high-level review.

In fact, I'm surprised at how much there is here.  The LLVM backend has more in common with the native code generators than the C backend, but I was expecting something closer to a straightforward pretty-printer.  I wonder if having a complete datatype for LLVM is really buying us anything since we don't actually do anything to it other than print it out.  As a quick example of what I mean, what would be lost if we replace

 data LlvmCastOp
   = LM_Trunc
   | LM_Zext
    ... lots of constructors ...
   deriving (Eq)

 instance Show LlvmCastOp where
   show LM_Trunc    = "trunc"
   show LM_Zext     = "zext"
   ...

with

 type LlvmCastOp = FastString
 lM_Trunc = fsLit "trunc"
 ...

?

Do we envisage doing anything complex to the Llvm code inside GHC in the future?  I can't think of a reason to.

Some of the cleanups and optimisations are quite significant.  Highlights:

  * I think the module LlvmCodeGen.Regs can mostly go away.
  * There are some obvious representation changes that would improve
    performance (String -> FastString, [a] -> OrdList a).

Review key:

 XXX    This needs to be addressed before the patch goes in
 CLEAN  A potential cleanup (some of these are quite major)
 OPT    A possible optimisation

Patch review follows:

hunk ./compiler/ghc.cabal.in 44
+Flag llvm
+    Description: Build the LLVM code generator.
+    Default: False
+    Manual: True

CLEAN Is there a good reason to want to disable the LLVM support, or
can it always be compiled in?

+Flag unreg
+    Description: Build an unregistered version.
+    Default: False
+    Manual: True
+

XXX Is this necessary?  As far as I'm aware an unregisterised build
currently works.

hunk ./compiler/ghc.cabal.in 101
+    if flag(llvm)
+        CPP-Options: -DLLVM
+        if flag(unreg)
+            CPP-Options: -DNO_REGS -DUSE_MINIINTERPRETER

XXX Why is this necessary?  These CPP flags are added by GHC itself
(StaticFlagParser.unregFlags).

+type LMString   = String

OPT You probably want to use something better than String, perhaps
FastString.

+-- | Llvm variables
+data LlvmVar
+  -- references to variables with a global scope.
+  = LMGlobalVar LMString LlvmType LlvmLinkageType
+  -- references to variables local for a function or parameters.
+  | LMLocalVar  LMString LlvmType
+  -- a constant variable
+  | LMLitVar  LlvmLit

OPT Rather than LMString in LMLocalVar, probably Unique would be
better.  I think you always generate these from a Unique (but I could
be wrong) in which case it would be better to do that conversion when
printing.  I'm not sure whether this applies to LMGlobalVar or not.

+  deriving (Eq)
+fixAssignsTop :: RawCmmTop -> UniqSM RawCmmTop
+
+fixAssignsTop top@(CmmData _ _) = returnUs top
+
+fixAssignsTop (CmmProc info lbl params (ListGraph blocks)) =
+    mapUs fixAssignsBlock blocks `thenUs` \ blocks' ->
+    returnUs (CmmProc info lbl params (ListGraph blocks'))
+

CLEAN I think your local fixAssigns can go away  (see comment with
LlvmCodeGen.Regs below): use the one from the NCG.

+cmmToCmm :: RawCmmTop -> RawCmmTop
+cmmToCmm top@(CmmData _ _) = top
+cmmToCmm (CmmProc info lbl params (ListGraph blocks)) =
+    let blocks'  = map cmmBlockConFold (cmmMiniInline blocks)
+        blocks'' = map cmmAddReturn blocks'
+    in CmmProc info lbl params (ListGraph $ blocks'')
+

CLEAN I think your local cmmToCmm can go away (see comment with
LlvmCodeGen.Regs below): use the one from the NCG.  We should also
look into not doing any optimisation at the C-- level at all, since
LLVM will do it all, however we do need to turn GlobalRegs into
BaseReg offsets where necessary, which is done by cmmToCmm.

+type LlvmEnvMap = Map.Map LMString LlvmType

OPT A Map of Strings is very inefficient compared with a UniqFM of
FastStrings.

+type StmtData = (LlvmEnv, [LlvmStatement], [LlvmCmmTop])

OPT Use OrdList rather than lists here, as you're doing a lot of
appending.  Append is O(1) in OrdList, O(n) with lists.

+type ExprData = (LlvmEnv, LlvmVar, LlvmStatements, [LlvmCmmTop])

OPT Again, LlvmStatements should probably be an OrdList.

addfile ./compiler/llvmGen/LlvmCodeGen/Regs.hs
hunk ./compiler/llvmGen/LlvmCodeGen/Regs.hs 1
+-- ----------------------------------------------------------------------------
+-- Deal with Cmm registers
+--
+-- Specifically, force use of register table (in memory), not pinned
+-- hardware registers as the LLVM back-end doesn't support this.
+--
+
+module LlvmCodeGen.Regs (
+
+        RealReg, realRegsOrdered, getRealRegReg, getRealRegArg, getGlobalRegAddr
+
+    ) where

CLEAN Unless I'm mistaken, most of this module can go away.

 1. Use fixAssigns from the NCG.
 2. Print out GlobalRegs as "stg_whatever..."

Then you don't need to bake in the register mapping (a maintenance
headache), and a lot of this code can go away: the RealReg type and
everything using it.


addfile ./compiler/llvmGen/NOTES
hunk ./compiler/llvmGen/NOTES 1
+LLVM Back-end for GHC.
+
+Author: David Terei

CLEAN Useful-looking docs.  I suggest moving them into either (a) the wiki commentary or (b) the code as appropriate.

hunk ./compiler/main/CodeOutput.lhs 16
+#ifdef LLVM
+#ifdef OMIT_NATIVE_CODEGEN
+import UniqSupply    ( mkSplitUniqSupply )
+#endif
+import qualified LlvmCodeGen ( llvmCodeGen )
+#endif
+
hunk ./compiler/main/CodeOutput.lhs 90
+             HscLlvm        -> outputLlvm dflags filenm flat_abstractC;
hunk ./compiler/main/CodeOutput.lhs 176
+%************************************************************************
+%*                                    *
+\subsection{LLVM}
+%*                                    *
+%************************************************************************
+
+\begin{code}
+outputLlvm :: DynFlags -> FilePath -> [RawCmm] -> IO ()
+
+#ifdef LLVM
+
+outputLlvm dflags filenm flat_absC
+  = do ncg_uniqs <- mkSplitUniqSupply 'n'
+       doOutput filenm $ \f ->
+             LlvmCodeGen.llvmCodeGen dflags f ncg_uniqs flat_absC
+
+#else /* !LLVM */

CLEAN suggest removing the #ifdefs and enabling LLVM unconditionally, as above. 

